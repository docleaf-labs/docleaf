"""
Designed to generate a rust module of types from an xsd file.

Xsd entry:

  <xsd:complexType name="compounddefType">
    <xsd:sequence>

Should map to a Rust struct with fields for child elements and attributes.

  <xsd:complexType name="incType">
    <xsd:simpleContent>

According to Wikipedia, simple content refers to text being allowed but no child elements.

  <xsd:complexType name="highlightType" mixed="true">
    <xsd:choice minOccurs="0" maxOccurs="unbounded">

mixed=true means that it should be a struct with a field to represent an array of entries which can either be text
or the child elements described by the xsd.

choice indicates that only one of the contained elements can be allowed which corresponds to an enum. If multiple
entries are allowed then we assume it means something like a Vec of an enum value


"""
from collections import defaultdict
from pprint import pprint
from typing import List
import xml.etree.ElementTree as ET
import re
import sys


class DocComment:
    def __init__(self, content: List[str]):
        self.content = content

    def to_string(self):
        return "//! " + "\n//! ".join(self.content)


class Struct:
    def __init__(self, name, field_groups):
        self.name = name
        self.field_groups = field_groups

    def to_string(self):
        field_groups_text = []
        for group, fields in self.field_groups.items():
            if group:
                field_groups_text.append(f"// {group}")

            fields = ",\n".join(fields)
            fields = f"{fields}," if fields else fields

            field_groups_text.append(fields)

        field_groups_text = "\n".join(field_groups_text)
        return f"""
#[derive(Debug, PartialEq)]
pub struct {self.name} {{
{field_groups_text}
}}
"""


class Enum:
    def __init__(self, name, simple, entries):
        self.name = name
        self.entries = entries
        self.simple = simple

    def to_string(self):
        enum_string = "strum::EnumString, " if self.simple else ""
        return f"""
#[derive(Debug, {enum_string}PartialEq)]
pub enum {self.name} {{
    {self.entries}
}}
"""


class Text:
    def __init__(self, content):
        self.content = content

    def to_string(self):
        return self.content


def main(args):
    target_xsd_file = args[0]
    target_rs_file = args[1]

    comment_lookup = generate_comment_lookup(target_rs_file)

    tree = ET.parse(target_xsd_file)
    root = tree.getroot()

    with open(target_rs_file, "w") as output:
        entries = []

        entries.append(
            DocComment(
                [
                    "Automatically generated by:",
                    "",
                    f"   generate.py {' '.join(args)}",
                    "",
                ]
            )
        )

        for child in root:
            if "name" in child.attrib:
                if child.tag == "{http://www.w3.org/2001/XMLSchema}complexType":
                    if is_simple_content(child):
                        entries.extend(create_simple_content(child, comment_lookup))
                    elif "mixed" in child.attrib:
                        mixed = create_mixed(output, child)
                        if mixed:
                            entries.extend(mixed)
                    else:
                        entries.extend(create_struct(output, child, comment_lookup))
                elif child.tag == "{http://www.w3.org/2001/XMLSchema}simpleType":
                    for grandchild in child:
                        if grandchild.tag == "{http://www.w3.org/2001/XMLSchema}restriction":
                            name = child.attrib["name"]
                            restriction = create_restriction(output, name, grandchild)
                            if restriction:
                                entries.extend(restriction)

        for entry in entries:
            print(entry.to_string(), file=output)


def is_simple_content(tag) -> bool:
    for child in tag:
        # print(child)
        if child.tag == "{http://www.w3.org/2001/XMLSchema}simpleContent":
            return True

    return False


def create_simple_content(tag, comment_lookup):
    name = convert_type_name(tag.attrib["name"], False)

    simple_content = None
    for child in tag:
        if child.tag == "{http://www.w3.org/2001/XMLSchema}simpleContent":
            simple_content = child

    if not simple_content:
        return []

    for child in simple_content:
        if child.tag == "{http://www.w3.org/2001/XMLSchema}extension":
            type = child.attrib["base"]
            attribute_fields = get_attribute_fields(child, name, comment_lookup)

            type = convert_type_name(type, True)
            fields = {"Attributes": attribute_fields, "Content": [f"content: {type}"]}

            return [Struct(name, fields)]

    return []


def create_struct(output, tag, comment_lookup):
    """
    Output a rust struct for a given xsd tag
    """

    name = convert_type_name(tag.attrib["name"], False)

    attribute_fields = get_attribute_fields(tag, name, comment_lookup)
    element_fields = []
    for child in tag:

        if child.tag == "{http://www.w3.org/2001/XMLSchema}sequence":
            for element in child:
                if "name" in element.attrib:
                    field_name = convert_field_name(element.attrib["name"])
                    # Some elements don't have a 'type' attribute, I'm not sure if "String" is a reasonable fallback
                    # but we'll try it until proven wrong
                    field_type = (
                        convert_type_name(element.attrib["type"], True)
                        if "type" in element.attrib
                        else "String"
                    )

                    min_occurs = (
                        int(element.attrib["minOccurs"]) if "minOccurs" in element.attrib else 1
                    )

                    max_occurs = element.attrib["maxOccurs"] if "maxOccurs" in element.attrib else 1

                    # Robust comment lookup by using fallbacks
                    comment = (
                        "// "
                        if comment_lookup.get(name.lower(), {}).get(field_name.lower(), True)
                        else ""
                    )

                    if min_occurs == 0 and max_occurs in [1, "1"]:
                        element_fields.append(
                            f"    {comment}pub {field_name}: Option<{field_type}>"
                        )
                    elif min_occurs == 0 and max_occurs == "unbounded":
                        element_fields.append(f"    {comment}pub {field_name}: Vec<{field_type}>")
                    elif min_occurs == 1 and max_occurs == "unbounded":
                        element_fields.append(
                            f"    {comment}pub {field_name}: vec1::Vec1<{field_type}>"
                        )
                    elif min_occurs == 1 and max_occurs in [1, "1"]:
                        element_fields.append(f"    {comment}pub {field_name}: {field_type}")
                    else:
                        raise Exception(f"min:{repr(min_occurs)} max:{repr(max_occurs)}")

    return [Struct(name, {"Attributes": attribute_fields, "Elements": element_fields})]


def create_mixed(output, tag):
    """
    Output a rust enum for a mixed complex type
    """

    name = convert_type_name(tag.attrib["name"], False)

    entries = []
    for child in tag:
        if child.tag == "{http://www.w3.org/2001/XMLSchema}sequence":
            for grandchild in child:
                # print(child)
                # print(grandchild)
                if "name" in grandchild.attrib and "type" in grandchild.attrib:
                    entry_name = grandchild.attrib["name"]
                    entry_type = grandchild.attrib["type"]
                    entry_name = convert_type_name(entry_name, False)
                    entry_type = convert_type_name(entry_type, False)
                    entries.append(f"{entry_name}({entry_type})")

            entries.append("Text(String)")

            entries = ",\n    ".join(entries)

        if child.tag == "{http://www.w3.org/2001/XMLSchema}group":
            if "name" in child.attrib:
                entries.append(child.attrib["name"])

    if not entries:
        return

    item_name = name + "Item"

    return [Struct(name, {"": [f"contents: {item_name}"]}), Enum(item_name, False, entries)]


def create_restriction(output, name, tag):
    """
    Output a rust enum for a given xsd tag
    """

    # Handle special cases which are patterns rather than enums
    if name in ["DoxVersionNumber", "DoxCharRange"]:
        return [Text(f"type {name} = String;")]

    # Skip weird type until we need it
    if name in ["DoxOlType", "DoxBool"]:
        return

    name = convert_type_name(name, False)

    entries = []
    for child in tag:
        entry_name = child.attrib["value"]
        entry_name = convert_enum_name(entry_name)
        entries.append(entry_name)

    entries = ",\n    ".join(entries)

    return [Enum(name, True, entries)]


def convert_enum_name(name):
    name = capitalize(name)
    # print(name, file=sys.stderr)
    while True:
        match = re.search("-[A-Za-z]", name)
        if match:
            span = match.span()
            # print(match.group(), file=sys.stderr)
            name = name[: span[0]] + match.group()[1:].upper() + name[span[1] :]
            # print(name, file=sys.stderr)
        else:
            break

    name = name.replace("#", "Sharp")
    name = name.replace("+", "Plus")

    return name


def get_attribute_fields(element, name, comment_lookup):

    fields = []

    for child in element:
        if child.tag == "{http://www.w3.org/2001/XMLSchema}attribute":
            if "name" in child.attrib:
                field_name = convert_field_name(child.attrib["name"])
                field_type = convert_type_name(child.attrib["type"], True)

                # Robust comment lookup by using fallbacks
                comment = (
                    "// "
                    if comment_lookup.get(name.lower(), {}).get(field_name.lower(), True)
                    else ""
                )

                fields.append(f"  {comment}pub {field_name}: {field_type}")

    return fields


def capitalize(name):
    return name[0].upper() + name[1:]


type_lookup = {
    "xsd:string": "String",
    "xsd:integer": "i32",
    "DoxBool": "bool",
    "DoxOlType": "String",
}


def convert_type_name(name, as_field_type):
    if name in type_lookup:
        return type_lookup[name]

    name = capitalize(name)
    name = name.replace("def", "Def")
    name = name.replace("type", "Type")
    name = name.replace("kind", "Kind")
    name = name.replace("class", "Class")
    name = name.replace("value", "Value")
    name = name.replace("param", "Param")
    name = name.replace("list", "List")
    name = name.replace("contents", "Contents")
    name = name.replace("ofC", "OfC")

    return name


field_lookup = {
    "compounddef": "compound_def",
    "compoundname": "compound_name",
    "sectiondef": "section_defs",
    "memberdef": "member_defs",
    "briefdescription": "brief_description",
    "detaileddescription": "detailed_description",
}


def convert_field_name(name):
    keywords = ["ref", "type", "static", "const", "final", "abstract"]
    if name in keywords:
        return f"{name}_"

    name = field_lookup.get(name.lower(), name)
    return name


def generate_comment_lookup(filepath):
    """
    Parses the current rust file with regexes to track which fields in which structs have
    been commented out so we can put those comments in when re-creating the file. This means
    that we're free to comment fields during development and not have to deal with them
    being uncommented by the script if we need to regenerate anything.
    """

    lookup = defaultdict(dict)
    key = None

    struct_re = re.compile(r"pub struct (.*) \{")
    enum_re = re.compile(r"pub enum (.*) \{")
    field_re = re.compile(r"    pub (.*): .*")
    comment_field_re = re.compile(r"    // pub (.*): .*")

    with open(filepath) as f:
        for line in f:
            if match := struct_re.match(line):
                # Lower case entries to make them robust to future case changes
                key = match.group(1).lower()
            elif match := enum_re.match(line):
                key = None
            elif match := field_re.match(line):
                if key:
                    # Lower case entries to make them robust to future case changes
                    lookup[key][match.group(1).lower()] = False
            elif match := comment_field_re.match(line):
                if key:
                    # Lower case entries to make them robust to future case changes
                    lookup[key][match.group(1).lower()] = True

    return lookup


if __name__ == "__main__":
    main(sys.argv[1:])
